<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8">
<title>JS13kgames 2020 - 404</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>* {
  margin: 0;
  padding: 0;
}

body {
  color: black;
  background-color: white;
}

#app {
  height: 95vmin;
  width: 95vmin;
}

.hidden.world {
  display: none;
}

.background,
.middleground,
.foreground {
  fill: hsl(
    var(--hue),
    var(--saturation),
    var(--luminance)
  );
}

.four-portal {
  fill: transparent;
  stroke-width: var(--strokeWidth);
  stroke: hsl(
    var(--hue),
    var(--saturation),
    var(--luminance)
  );
}

.sun {
  fill: gold;
}

.time {
  font-size: 0.2em;
}

.slidein {
  animation-name: slidein;
  animation-duration: 3s;
  animation-timing-function: ease-in-out; /* Or cubic-bezier(0.1, 0.7, 1.0, 0.1); */
  animation-delay: 0;
  animation-iteration-count: 3;
  animation-direction: alternate;
  animation-fill-mode: forwards;
}

@media (any-hover: hover) {
  /* :hover can be used */
  /* alternative value: any-hover: none */
}

@media (any-pointer: coarse) {
  /* A pointer device such as mouse is available */
  /* alternative values: none | fine */
}

@media (min-aspect-ratio: 4/3) {
}

@media (max-aspect-ratio: 16/9) {
}

@media (aspect-ratio: 1/1) {
}

@media (color) {
  /* Supports colour! */
  /* Opposite would be @media (monochrome) {} */
}

@media (orientation: portrait) {
  /* Alternative value: landscape */
}

@media (prefers-color-scheme: dark) {
  /* Alternative value: light */
}

@media (prefers-reduced-motiion: reduce) {
  /* Reduce animations */
  /* Alternative value: no-preference */
}

@media (min-resolution: 72dpi) {
}

@media (max-resolution: 300dpi) {
}
</style></head>
<body>
<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" id="app">
</svg>
<button id="action" type="button">Start time</button>
<script>/**
 * This file is part of JS13kGames - 404.
 * An Offline Life is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * An Offline Life is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with An Offline Life.  If not, see <https://www.gnu.org/licenses/>.
 */

(function () {
  'use strict';

  const EVENTS = {
    TICK: 'game:time:update',
    TURN: 'game:controls:turn',
    WIND: 'world:weather:wind',
  };

  class WithBoundingBox {
    constructor (properties) {
      const { x, y, height, width } = properties.boundingBox;
      this._boundingBox = {
        x,
        y,
        h: height,
        w: width
      };
    }
  }

  // TODO: Turn into real mixin
  class WithEventListener extends WithBoundingBox {
    constructor (properties) {
      super(properties);
      this._eventNode = properties.eventNode;

      Object.keys(this._getEventMap()).forEach((eventName) => {
        this._eventNode.addEventListener(eventName, this, false);
      });
    }

    // Implementation of EventHandler interface
    handleEvent (event) {
      const { detail, isTrusted, target, type } = event;
      const callback = this._getEventMap()[ type ];

      if (callback) {
        // Native Events
        if (isTrusted && target) {
          callback(target);
          return
        }

        // Custom Events
        if (!isTrusted && detail) {
          callback(detail);
          return
        }

        // Everything else
        console.warn(`Unknown event type ${type}`);
        callback(event);
        return
      } else {
        console.warn(`No callback for ${event.type}`);
      }
    }

    _getEventMap () {
      // To be overriden by sub-classes
      return {}
    }
  }

  // TODO: Turn into real mixin
  class WithParent extends WithEventListener {
    constructor (properties) {
      super(properties);
      this._mount(properties.parent);
    }

    _mount (parent) {
      throw new Error('Requires implementation')
    }

    _updateView () {
      throw new Error('Requires implementation')
    }

    _createSvgElement (name, attributes = {}, classes = []) {
      const ns = 'http://www.w3.org/2000/svg';
      const element = document.createElementNS(ns, name);

      Object.keys(attributes).forEach((attribute) => {
        const value = attributes[ attribute ];
        element.setAttributeNS(null, attribute, value);
      });

      classes.forEach((className) => {
        element.classList.add(className);
      });

      return element
    }
  }

  class Controls extends WithParent {
    _getEventMap () {
      return { click: this._handleClick.bind(this) }
    }

    _handleClick (eventTarget) {
      const isLeftControl = eventTarget.classList.contains('left');
      const isRightControl = eventTarget.classList.contains('right');

      if (isLeftControl) {
        const event = new CustomEvent(
          EVENTS.TURN,
          { detail: { direction: 'left' }}
        );
        this._eventNode.dispatchEvent(event);
        console.log('Dispatched', event, 'on', this._eventNode);
      }

      if (isRightControl) {
        const event = new CustomEvent(
          EVENTS.TURN,
          { detail: { direction: 'right' }}
        );
        this._eventNode.dispatchEvent(event);
      }
    }

    _mount (parent) {
      this.element = this._createSvgElement('g', {}, [ 'controls' ]);
      parent.appendChild(this.element);

      this._mountLeft();
      this._mountTop();
      this._mountRight();
    }

    _mountLeft () {
      const { x, y, h, w } = this._boundingBox;
      const top = y + h / 2;
      const bottom = y + h;
      const left = x;
      const right = x + w / 3;

      const points = [
        right + ',' + top,
        right + ',' + bottom,
        left  + ',' + (top + bottom) / 2
      ].join(' ');

      const control = this._createSvgElement(
        'polygon',
        { points },
        [ 'left', 'control' ]
      );
      this.element.appendChild(control);
    }

    _mountRight () {
      const { x, y, h, w } = this._boundingBox;
      const top = y + h / 2;
      const bottom = y + h;
      const left = x + w * 2 / 3;
      const right = x + w;

      const points = [
        left + ',' + top,
        left + ',' + bottom,
        right  + ',' + (top + bottom) / 2
      ].join(' ');

      const control = this._createSvgElement(
        'polygon',
        { points },
        [ 'right', 'control' ]
      );
      this.element.appendChild(control);
    }

    _mountTop () {
      const { x, y, h, w } = this._boundingBox;
      const top = y;
      const bottom = y + h / 2;
      const left = x + w / 3;
      const right = x + w * 2 / 3;

      const points = [
        right + ',' + bottom,
        left + ',' + bottom,
        (right + left) / 2  + ',' + top
      ].join(' ');

      const control = this._createSvgElement(
        'polygon',
        { points },
        [ 'top', 'control' ]
      );
      this.element.appendChild(control);
    }
  }

  class Time extends WithParent {
    constructor (properties) {
      super(properties);

      this.clock = {
        hour: 0,
        minute: 0
      };
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      if (!clock.hour || !clock.minute) {
        console.warn('Invalid event', clock);
        return
      }

      const hour = clock.hour;
      const minute = ('00' + clock.minute).slice(-2);
      this.clock = {
        hour,
        minute
      };
      this._updateView();
    }

    _mount (parent) {
      const { x, y } = this._boundingBox;
      this.element = this._createSvgElement(
        'text',
        { x, y },
        [ 'time' ]
      );

      const text = document.createTextNode('');
      this.element.appendChild(text);
      parent.appendChild(this.element);
    }

    _updateView () {
      const { hour, minute } = this.clock;
      this.element.textContent = `${hour}:${minute}`;
    }
  }

  class Background extends WithParent {
    constructor (properties) {
      super(properties);

      this._hue = 211;
      this._saturation = 70;
      this._luminance = 50;

      this._timeoutHandle = null;
      this._updateView();
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      // TODO: Extract into mixin for shared code with Sun
      const isMorning = clock.hour > 5 && clock.hour < 8;
      const isEvening = clock.hour > 17 && clock.hour < 20;

      const delta = 6 / 60;  // change per minute

      if (isEvening) {
        this._luminance -= delta;
      }

      if (isMorning) {
        this._luminance += delta;
      }

      this._updateView();
    }

    _mount (parent) {
      const { x, y, h, w } = this._boundingBox;
      this.element = this._createSvgElement(
        'rect',
        {
          x,
          y,
          height: h,
          width: w
        },
        [ 'background' ]
      );

      parent.appendChild(this.element);
    }

    _updateView () {
      this.element.style.setProperty('--hue', this._hue + '', '');
      this.element.style.setProperty('--saturation', this._saturation + '%', '');
      this.element.style.setProperty('--luminance', this._luminance + '%', '');
    }
  }

  class Foreground extends WithParent {
    constructor (properties) {
      super(properties);

      this._hue = 140;
      this._saturation = 50;
      this._luminance = 50;

      this._timeoutHandle = null;
      this._updateView();
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      // TODO: Extract into mixin
      const isMorning = clock.hour > 5 && clock.hour < 8;
      const isEvening = clock.hour > 17 && clock.hour < 20;

      const delta = 6 / 60;  // change per minute

      if (isEvening) {
        this._luminance -= delta;
      }

      if (isMorning) {
        this._luminance += delta;
      }

      this._updateView();
    }

    _mount (parent) {
      const { x, y, h, w } = this._boundingBox;
      this.element = this._createSvgElement(
        'rect',
        {
          x,
          y,
          height: h,
          width: w
        },
        [ 'foreground' ]
      );

      parent.appendChild(this.element);
    }

    _updateView () {
      this.element.style.setProperty('--hue', this._hue + '', '');
      this.element.style.setProperty('--saturation', this._saturation + '%', '');
      this.element.style.setProperty('--luminance', this._luminance + '%', '');
    }
  }

  class Middleground extends WithParent {
    constructor (properties) {
      super(properties);

      this._hue = 140;
      this._saturation = 50;
      this._luminance = 30;

      this._timeoutHandle = null;
      this._updateView();
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      // TODO: Extract into mixin
      const isMorning = clock.hour > 5 && clock.hour < 8;
      const isEvening = clock.hour > 17 && clock.hour < 20;

      const delta = 6 / 60;  // change per minute

      if (isEvening) {
        this._luminance -= delta;
      }

      if (isMorning) {
        this._luminance += delta;
      }

      this._updateView();
    }

    _mount (parent) {
      const { x, y, h, w } = this._boundingBox;
      this.element = this._createSvgElement(
        'rect',
        {
          x,
          y,
          height: h,
          width: w
        },
        [ 'middleground' ]
      );

      parent.appendChild(this.element);
    }

    _updateView () {
      this.element.style.setProperty('--hue', this._hue + '', '');
      this.element.style.setProperty('--saturation', this._saturation + '%', '');
      this.element.style.setProperty('--luminance', this._luminance + '%', '');
    }
  }

  class Castle extends WithParent {
    _mount (parent) {
      this.element = this._createSvgElement(
        'g',
        {},
        [ 'castle' ]
      );

      parent.appendChild(this.element);
      this._mountLeftTower();
      this._mountMain();
      this._mountCrenellations(4);
      this._mountRightTower();
    }

    _mountCrenellations (numberOfCrenellations) {
      const { x, y, h, w } = this._boundingBox;

      const breadth = w * 0.7 / (numberOfCrenellations * 2 + 1);
      const left = x + w * 0.15;
      const top = y + h * 0.1;
      const bottom = y + h * 0.2;

      const points = [
        left  + ',' + bottom,
      ];

      for (let i = 1; i < numberOfCrenellations * 2; i += 2) {
        const right = left + (i + 1) * breadth;

        points.push((left + i * breadth) + ',' + bottom);
        points.push((left + i * breadth) + ',' + top);
        points.push(right                + ',' + top);
        points.push(right                + ',' + bottom);
      }

      const crenellations = this._createSvgElement(
        'polygon',
        { points: points.join(' ') },
        [ 'crenellations' ]
      );
      this.element.appendChild(crenellations);
    }

    _mountLeftTower () {
      const { x, y, h, w } = this._boundingBox;

      const left = x;
      const right = x + w * 0.15;
      const top = y;
      const bottom = y + h;

      const points = [
        left  + ',' + bottom,
        left  + ',' + top,
        right + ',' + top,
        right + ',' + bottom
      ].join(' ');

      const tower = this._createSvgElement(
        'polygon',
        { points },
        [ 'tower' ]
      );
      this.element.appendChild(tower);
    }

    _mountMain () {
      const { x, y, h, w } = this._boundingBox;

      const left = x + w * 0.15;
      const right = x + w - w * 0.15;
      const top = y + h * 0.2;
      const bottom = y + h;

      const points = [
        left  + ',' + bottom,
        left  + ',' + top,
        right + ',' + top,
        right + ',' + bottom
      ].join(' ');

      const main = this._createSvgElement(
        'polygon',
        { points },
        []
      );
      this.element.appendChild(main);
    }

    _mountRightTower () {
      const { x, y, h, w } = this._boundingBox;

      const left = x + w - w * 0.15;
      const right = x + w;
      const top = y;
      const bottom = y + h;

      const points = [
        left  + ',' + bottom,
        left  + ',' + top,
        right + ',' + top,
        right + ',' + bottom
      ].join(' ');

      const tower = this._createSvgElement(
        'polygon',
        { points },
        [ 'tower' ]
      );
      this.element.appendChild(tower);
    }
  }

  class Mill extends WithParent {
    constructor (properties) {
      super(properties);

      const { x, y, h, w } = this._boundingBox;
      this._windStrength = 'still';
      this._axisX = x + w * 0.5;
      this._axisY = y + h * 0.3;
      this.degree = 0;

      this._updateView();
    }

    _getElementAttributes () {
      const { x, y, h, w } = this._boundingBox;

      this._axisX = this._axisX || x + w * 0.5;
      this._axisY = this._axisY || y + h * 0.5;
      this._degree = this._degree || 0;

      return {
        axisX: this._axisX,
        axisY: this._axisY,
        degree: this._degree
      }
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this),
        [ EVENTS.WIND ]: this._handleWorldWeatherWind.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      if (!clock.hour || !clock.minute) {
        console.warn('Invalid event', clock);
        return
      }

      // Must be divisable by 2/3 without remainder!
      let factor = 1.5;

      if (this._windStrength === 'medium') {
        factor = 6;
      }

      if (this._windStrength === 'strong') {
        factor = 9;
      }

      this._degree = clock.minute * factor;
      this._updateView();
    }

    _handleWorldWeatherWind (eventDetail) {
      this._windStrength = eventDetail.wind;
      this._updateView();
    }

    _mount (parent) {
      this.element = this._createSvgElement(
        'g',
        {},
        [ 'mill' ]
      );
      parent.appendChild(this.element);
      this._mountBuilding();
      this._mountWings();
    }

    _mountBuilding () {
      const { x, y, h, w } = this._boundingBox;

      const left = x + w * 0.3;
      const right = x + w * 0.7;
      const top = y + h * 0.3;
      const bottom = y + h;

      const points = [
        left              + ',' + bottom,
        (left + w * 0.1)  + ',' + top,
        (right - w * 0.1) + ',' + top,
        right             + ',' + bottom
      ].join(' ');

      const building = this._createSvgElement(
        'polygon',
        { points },
        []
      );
      this.element.appendChild(building);
    }

    _mountWings () {
      const wings = this._createSvgElement(
        'g',
        {},
        [ 'wings' ]
      );
      this._mountTopWing(wings);
      this._mountRightWing(wings);
      this._mountBottomWing(wings);
      this._mountLeftWing(wings);
      this.element.appendChild(wings);
    }

    _mountBottomWing (parent) {
      const { x, y, h, w } = this._boundingBox;
      const { axisX, axisY } = this._getElementAttributes();

      const left = axisX - w * 0.01;
      const right = axisX + w * 0.01;
      const top = axisY + h * 0.01;
      const bottom = axisY + h * 0.3;
      const middle = bottom - h * 0.2;

      const points = [
        right              + ',' + top,
        right              + ',' + bottom,
        left               + ',' + bottom,
        left               + ',' + middle,
        (right - w * 0.02) + ',' + middle,
        (right - w * 0.02) + ',' + top
      ].join(' ');

      const wing = this._createSvgElement(
        'polygon',
        { points },
        [ 'bottom', 'wing' ]
      );
      parent.appendChild(wing);
    }

    _mountLeftWing (parent) {
      const { x, y, h, w } = this._boundingBox;
      const { axisX, axisY } = this._getElementAttributes();

      const left = axisX - w * 0.3;
      const right = axisX - w * 0.01;
      const top = axisY - h * 0.1;
      const bottom = axisY + h * 0.01;
      const middle = left + w * 0.2;

      const points = [
        right  + ',' + bottom,
        left   + ',' + bottom,
        left   + ',' + top,
        middle + ',' + top,
        middle + ',' + (bottom - h * 0.02),
        right  + ',' + (bottom - h * 0.02)
      ].join(' ');

      const wing = this._createSvgElement(
        'polygon',
        { points },
        [ 'left', 'wing' ]
      );
      parent.appendChild(wing);
    }

    _mountRightWing (parent) {
      const { x, y, h, w } = this._boundingBox;
      const { axisX, axisY } = this._getElementAttributes();

      const left = axisX + w * 0.01;
      const right = axisX + w * 0.3;
      const top = axisY - h * 0.01;
      const bottom = axisY + h * 0.1;
      const middle = right - w * 0.2;

      const points = [
        left   + ',' + top,
        right  + ',' + top,
        right  + ',' + bottom,
        middle + ',' + bottom,
        middle + ',' + (top + h * 0.02),
        left   + ',' + (top + h * 0.02)
      ].join(' ');

      const wing = this._createSvgElement(
        'polygon',
        { points },
        [ 'right', 'wing' ]
      );
      parent.appendChild(wing);
    }

    _mountTopWing (parent) {
      const { x, y, h, w } = this._boundingBox;
      const { axisX, axisY } = this._getElementAttributes();

      const left = axisX - w * 0.01;
      const right = axisX + w * 0.1;
      const top = axisY + h * 0.3;
      const bottom = axisY - h * 0.01;
      const middle = top + h * 0.2;

      const points = [
        left              + ',' + bottom,
        left              + ',' + top,
        right             + ',' + top,
        right             + ',' + middle,
        (left + w * 0.02) + ',' + middle,
        (left + w * 0.02) + ',' + bottom
      ].join(' ');

      const wing = this._createSvgElement(
        'polygon',
        { points },
        [ 'top', 'wing' ]
      );
      parent.appendChild(wing);
    }

    _updateView () {
      const degree = this._degree;
      const origin = this._axisX + ',' + this._axisY;
      const rotate = `rotate(${degree},${origin})`;

      const wings = this.element.querySelector('.wings');
      wings.setAttributeNS(null, 'transform', rotate);
    }
  }

  class Sun extends WithParent {
    constructor (properties) {
      super(properties);

      this._radius = 3;
      this._axisX = this._boundingBox.x;
      this._axisY = this._boundingBox.y;
    }

    _getElementAttributes () {
      this._radius = this._radius || 3;
      this._axisX = this._axisX || this._boundingBox.x;
      this._axisY = this._axisY || this._boundingBox.y;

      return {
        r: this._radius,
        cx: this._axisX,
        cy: this._axisY
      }
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      const { hour, minute } = clock;
      if (!hour || !minute) {
        // TODO: Investigate
        console.warn('Invalid event', clock);
        return
      }

      const { x, y, h, w } = this._boundingBox;

      const dawn = 6;
      const dust = 18;

      const currentTime = (hour - dawn) * 60 + minute;
      const lengthOfDay = (dust - dawn) /* hours */ * 60; /* in minutes */
      const isDay = hour >= dawn && hour <= dust;

      let axisX = -5;

      if (isDay) {
        axisX = w * currentTime / lengthOfDay;
      }
      const angle = (hour + dawn) * 60 + minute;
      const lowerBorder = this._radius + h;
      const scale = h;

      const axisY = lowerBorder + scale * Math.sin(
        // Rescale to lengthOfDay
        angle * Math.PI / lengthOfDay
      );

      this._axisX = axisX;
      this._axisY = axisY;
      this._updateView();
    }

    _mount (parent) {
      const { r, cx, cy } = this._getElementAttributes();

      this.element = this._createSvgElement(
        'circle',
        {
          r: r + '',
          cx: cx - r * 3 + '',
          cy: cy - r * 3 + ''
        },
        [ 'sun' ]
      );
      parent.appendChild(this.element);
    }

    _updateView () {
      const cx = this._axisX;
      const cy = this._axisY;
      this.element.setAttributeNS(null, 'cx', cx + '');
      this.element.setAttributeNS(null, 'cy', cy + '');
    }
  }

  class BaseWorld extends WithParent {
    static worldName = 'base'

    constructor (properties) {
      super(properties);
      this._isActive = false;
      this._children = [];
      this._updateView();
    }

    addScene () {
      this._addBackground();
      this._addMiddleground();
      this._addForeground();
    }

    isActive () {
      return this._isActive
    }

    setActive () {
      this._isActive = true;
      this._updateView();
    }

    setInactive () {
      this._isActive = false;
      this._updateView();
    }

    _addBackground () {
      // To be implemented in sub-classes
    }

    _addForeground () {
      // To be implemented in sub-classes
    }

    _addMiddleground () {
      // To be implemented in sub-classes
    }

    _mount (parent) {
      const classes = ['world', 'world--' + this.constructor.worldName];
      this.element = this._createSvgElement('g', {}, classes);
      parent.appendChild(this.element);
    }

    _rollDice (min = 1, max = 6) {
      return Math.floor(Math.random() * ((max - min) + min) + min)
    }

    _updateView () {
      if (this.isActive()) {
        this.element.classList.remove('hidden');
      } else {
        this.element.classList.add('hidden');
      }
    }
  }

  class FourCastleWorld extends BaseWorld {
    static worldName = '4-castle'

    constructor (properties) {
      super(properties);

      this._windChangeHandle = null;
    }

    addScene () {
      this._addBackground();
      this._addSun();
      this._addMiddleground();
      this._addMill();
      this._addCastle();
      this._addForeground();

      this.fireWindChange();
      const self = this;
      const delay = 4 * 1000;  // TODO: Bind to clock
      this._windChangeHandle = setInterval(self.fireWindChange.bind(self), delay);
    }

    fireWindChange () {
      const dice = this._rollDice();

      const winds = [
        null,
        'still', 'still',
        'medium', 'medium', 'medium',
        'strong'
      ];

      const wind = winds[ dice ];
      const event = new CustomEvent(EVENTS.WIND, { detail: { wind }});
      this._eventNode.dispatchEvent(event);
    }

    _addBackground () {
      const { x, y, h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x,
          y,
          height: h / 3,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Background(properties);
    }

    _addCastle () {
      const { x, y, h, w } = this._boundingBox;
      const controlsWidth = 5 * 3;

      const properties = {
        boundingBox: {
          x: x + controlsWidth,
          y: y + h * 0.4,
          height: h / 4,
          width: x + w * 0.75 - controlsWidth * 2
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Castle(properties);
    }

    _addForeground () {
      const { x, y, h, w } = this._boundingBox;
      const backgroundHeight = h / 3;
      const middlegroundHeight = h / 5;
      const offset = y + backgroundHeight + middlegroundHeight;
      const remainingHeight = h - offset;

      const properties = {
        boundingBox: {
          x,
          y: offset,
          height: remainingHeight,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Foreground(properties);
    }

    _addMiddleground () {
      const { x, y, h, w } = this._boundingBox;
      const backgroundHeight = h / 3;

      const properties = {
        boundingBox: {
          x,
          y: backgroundHeight,
          height: h / 5,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Middleground(properties);
    }

    _addMill () {
      const { x, y, h, w } = this._boundingBox;

      const properties = {
        boundingBox: {
          x: x + w * 0.7,
          y: y + h * 0.3,
          height: h * 0.2,
          width: w * 0.2
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Mill(properties);
    }
    _addSun () {
      const { x, y, h, w } = this._boundingBox;
      const backgroundHeight = h / 3;

      const properties = {
        boundingBox: {
          x,
          y,
          height: backgroundHeight,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Sun(properties);
    }
  }

  class FourPortal extends WithParent {
    constructor (properties) {
      super(properties);

      this._hue = 0;
      this._saturation = 100;
      this._luminance = 50;
      this._updateView();
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      if (!clock.hour || !clock.minute) {
        console.warn('Invalid event', clock);
        return
      }

      this._hue = (clock.hour * 60 + clock.minute) / (24 * 60) * 360;
      this._updateView();
    }

    _mount (parent) {
      const strokeWidth = 8;
      const { x, y, h, w } = this._boundingBox;
      const points = [
        (x + w) / 2           + ',' + (y     + strokeWidth),
        (x + w - strokeWidth) + ',' + (y + h) / 2,
        (x + w) / 2           + ',' + (y + h - strokeWidth),
        (x     + strokeWidth) + ',' + (y + h) / 2
      ].join(' ');

      this.element = this._createSvgElement(
        'polygon',
        { points },
        [ 'four-portal' ]
      );

      this.element.style.setProperty('--strokeWidth',  strokeWidth + '', '');
      parent.appendChild(this.element);
    }

    _updateView () {
      this.element.style.setProperty('--hue', this._hue + '', '');
      this.element.style.setProperty('--saturation', this._saturation + '%', '');
      this.element.style.setProperty('--luminance', this._luminance + '%', '');
    }
  }

  class FourPortalWorld extends BaseWorld {
    static worldName = '4-portal'

    _addBackground () {
      const { x, y, h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x,
          y,
          height: h,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new FourPortal(properties);
    }
  }

  class Game {
    constructor (mountPoint) {
      // super(properties)
      this.clock = {
        minute: 0,
        hour: 5,
        day: 1
      };

      // Matches <svg> viewPort
      this._boundingBox = {
        x: 0,
        y: 0,
        h: 100,
        w: 100
      };

      // TODO: Think about dropping this property
      this._children = [];
      this._eventNode = mountPoint;
      this._parent = mountPoint;
      this._timeHandle = null;
      this._worlds = [];

      // TODO: Read from WithEventListener!
      Object.keys(this._getEventMap()).forEach((eventName) => {
        this._eventNode.addEventListener(eventName, this, false);
      });
    }

    addWorlds () {
      const { x, y, h, w } = this._boundingBox;

      const properties = {
        boundingBox: {
          x,
          y,
          height: h,
          width: w
        },
        eventNode: this._eventNode,
        parent: this._parent
      };

      const worlds = [{
        ctr: FourCastleWorld,
        left: FourPortalWorld.worldName,
        right: FourPortalWorld.worldName
      }, {
        ctr: FourPortalWorld,
        left: FourCastleWorld.worldName,
        right: FourCastleWorld.worldName
      }];

      worlds.forEach((w) => {
        const world = new w.ctr(properties);
        this._worlds.push({
          instance: world,
          name: w.ctr.worldName,
          left: w.left,
          right: w.right
        });

        world.addScene();
      });
    }

    fireNewTime () {
      this.clock.minute += 1;

      if (this.clock.minute >= 60) {
        this.clock.hour += 1;
        this.clock.minute -= 60;
      }

      if (this.clock.hour >= 24) {
        this.clock.day += 1;
        this.clock.hour -= 24;
      }

      const event = new CustomEvent(
        EVENTS.TICK,
        { detail: this.clock }
      );
      this._eventNode.dispatchEvent(event);
    }

    getCurrentWorld () {
      return this._worlds.find((world) => world.instance.isActive())
    }

    // TODO: Derive from WithEventListener!
    handleEvent (event) {
      const { detail, isTrusted, target, type } = event;
      const callback = this._getEventMap()[ type ];

      if (callback) {
        // Native Events
        if (isTrusted && target) {
          callback(target);
          return
        }

        // Custom Events
        if (!isTrusted && detail) {
          callback(detail);
          return
        }

        // Everything else
        console.warn(`Unknown event type ${type}`);
        callback(event);
        return
      } else {
        console.warn(`No callback for ${event.type}`);
      }
    }

    init () {
      const firstWorld = FourCastleWorld.worldName;

      this.addWorlds();
      // TODO: Only in debug builds?
      this._addTime();
      this._addControls();
      this.switchWorld(firstWorld);
    }

    pauseTime () {
      clearInterval(this._timeHandle);
    }

    startTime () {
      const fps = 33;
      const self = this;
      this._timeHandle = setInterval(self.fireNewTime.bind(self), fps);
    }

    switchWorld (nextWorld) {
      this._worlds.forEach((world) => world.instance.setInactive());
      const world = this._worlds.find((w) => w.name == nextWorld);
      world && world.instance.setActive();
    }

    _addControls () {
      const controlsHeight = 5 * 2;
      const controlsWidth = 5 * 3;

      // TODO: Consider left-handers!
      const controlsX = this._boundingBox.x + this._boundingBox.w - controlsWidth;
      const controlsY = this._boundingBox.y + this._boundingBox.h - controlsHeight;

      const properties = {
        boundingBox: {
          x: controlsX,
          y: controlsY,
          height: controlsHeight,
          width: controlsWidth
        },
        eventNode: this._eventNode,
        parent: this._parent
      };

      const controls = new Controls(properties);
    }

    _addTime () {
      const { h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x: 0.8 * h,
          y: 0.95 * w
        },
        eventNode: this._eventNode,
        parent: this._parent
      };

      const time = new Time(properties);
      this._children.push(time);
    }

    _getEventMap () {
      return {
        [ EVENTS.TURN ]: this._handleGameControlsTurn.bind(this)
      }
    }

    _handleGameControlsTurn (eventDetail) {
      const currentWorld = this.getCurrentWorld();
      const nextWorld = currentWorld[ eventDetail.direction ];
      this.switchWorld(nextWorld);
    }
  }

  const el = document.querySelector('#app');
  const game = new Game(el);
  game.init();

  let shallStart = true;

  document
    .getElementById('action')
    .addEventListener('click', () => {
      if (shallStart) {
        game.startTime();
      } else {
        game.pauseTime();
      }
      shallStart = !shallStart;
    }, false);

  // BIG Kudos to https://stackoverflow.com/a/16484266
  /*
  class World {
    constructor (element, data) {
      this.element = element
      this.data = data

      element.value = data
      element.addEventListener('change', this, false)
      element.addEventListener('click', this, false)
    }

    handleEvent (event) {
      switch (event.type) {
        case 'change':
          this.handleChange(this.element.value)
          break
        case 'click':
          this.handleClick()
          break
        default:
          // Do nothing
      }
    }

    handleChange (value) {
      this.data = value
      this.element.value = value
    }

    handleClick () {
      this.element.setAttributeNS(null, 'fill', `hsl(50, 0%, ${this.data}%)`)
      this.data += 2
    }
  }

  // TODO: Assign this to different children of #app
  // Modify World class to pass in the property to change. Perhaps a mapping of event to properties?
  // Allow for callbacks?
  new World(document.querySelector('#app rect'), 50)
  */

  /* Feature detection of Sensors API */
  /*
  if (typeof Gyroscope === 'function') {
  }

  if ('ProximitySensor' in window) {
  }

  if (window.Accelerometer) {
    console.log('Asking for permission to accelerometer')
    navigator.permissions.query({ name: 'accelerometer' })
             .then((result) => {
               if (result.state === 'denied') {
               console.log('Permission to use accelerometer sensor is denied.')
               return
             }
             console.log('Permission to use accelerometer sensor is granted.')

             let acl = new Accelerometer({ frequency: 60 })

             acl.addEventListener('reading', () => {
               console.log('Acceleration along the X-axis ' + acl.x)
               console.log('Acceleration along the Y-axis ' + acl.y)
               console.log('Acceleration along the Z-axis ' + acl.z)
             })

             acl.start()
             console.log('ACL', acl)
    })
  } else {
    console.info('No Accelerometer available')
  }

  if (window.AmbientLightSensor) {
    console.log('Asking for permission to ambient light sensor')
    navigator.permissions.query({ name: 'ambient-light-sensor' })
             .then((result) => {
               if (result.state === 'denied') {
               console.log('Permission to use ambient-light-sensor sensor is denied.')
               return
             }
             console.log('Permission to use ambient-light-sensor sensor is granted.')

             let sensor = new AmbientLightSensor()
             sensor.onreading = () => {
               console.log('Current light level: ', sensor.illuminance)
             }
             sensor.onerror = (event) => {
               console.error(event.error.name, event.error.message)
             }
             sensor.start()
             console.log('Ambient Light sensor', sensor)
    })
  } else {
    console.info('No AmbientLightSensor available')
  }

  if (window.Gyroscope) {
    console.log('Asking for permission to gyroscope')
    navigator.permissions.query({ name: 'gyroscope' })
             .then((result) => {
               if (result.state === 'denied') {
               console.log('Permission to use gyroscope sensor is denied.')
               return
             }
             console.log('Permission to use gyroscope sensor is granted.')

             let gyroscope = new Gyroscope({ frequency: 60 })

             gyroscope.addEventListener('reading', () => {
               console.log('Angular velocity along the X-axis ' + gyroscope.x)
               console.log('Angular velocity along the Y-axis ' + gyroscope.y)
               console.log('Angular velocity along the Z-axis ' + gyroscope.z)
             })

             gyroscope.start()
             console.log('Gyroscope', gyroscope)
    })
  } else {
    console.info('No Gyroscope available')
  }

  if (window.Magnetometer) {
    console.log('Asking for permission to magnetometer')
    navigator.permissions.query({ name: 'magnetometer' })
             .then((result) => {
               if (result.state === 'denied') {
               console.log('Permission to use magnetometer sensor is denied.')
               return
             }
             console.log('Permission to use magnetometer sensor is granted.')

             let magnetometer = new Magnetometer({ frequency: 60 })

             magnetometer.addEventListener('reading', () => {
               console.log('Magnetic field along the X-axis ' + magnetometer.x)
               console.log('Magnetic field along the Y-axis ' + magnetometer.y)
               console.log('Magnetic field along the Z-axis ' + magnetometer.z)
             })

             magnetometer.start()
             console.log('Magnetometer', magnetometer)
    })
  } else {
    console.info('No Magnetometer available')
  }
  */

  /* Sensors have the fields:
   * activated: Boolean
   * hasReading: Boolean
   * timestamp
   *
   * Sensors have the events:
   * reading
   * error
   * activated
   *
   * Sensors have the methods:
   * start()
   * stop()
   */

  /*
  radians = degrees * (pi/180)
  degrees = radians * (180/pi)
  */

  /*
   * x = r * cos(phi)
   * y = r * sin(phi)
   * r = (x * x + y * y)^(1/2)
   * phi = atan2(y, x) (= Math.atan2)
   */

  /*
  function handleMotionEvent(event) {
      var x = event.accelerationIncludingGravity.x
      var y = event.accelerationIncludingGravity.y
      var z = event.accelerationIncludingGravity.z

      // Do something awesome.
  }

  window.addEventListener('devicemotion', handleMotionEvent, true)

  if (window.DeviceOrientationEvent) {
      window.addEventListener('deviceorientation', function(event) {
          // alpha: rotation around z-axis
          var rotateDegrees = event.alpha
          // gamma: left to right
          var leftToRight = event.gamma
          // beta: front back motion
          var frontToBack = event.beta

          handleOrientationEvent(frontToBack, leftToRight, rotateDegrees);
      }, true)
  }

  var handleOrientationEvent = function(frontToBack, leftToRight, rotateDegrees) {
      // do something amazing
  }
  */

}());
</script>

</body></html>