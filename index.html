<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8">
<title>JS13kgames 2020 - 404</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>*{margin:0;padding:0}body{color:#000;background-color:#fff;display:flex;flex-direction:column}body>section{flex:1}.nav-list{display:flex;list-style:none;align-items:center}.nav-list__item{flex:1}.tab-view:not(:target){display:none}#app{display:block;height:98vmin;width:98vmin;margin-left:auto;margin-right:auto;margin-inline-start:auto;margin-inline-end:auto}.hidden.world{display:none}.background,.foreground,.middleground{fill:hsl(var(--hue),var(--saturation),var(--luminance))}.five-portal,.four-portal,.six-portal,.three-portal{fill:transparent;stroke-width:var(--strokeWidth);stroke:hsl(var(--hue),var(--saturation),var(--luminance))}.sun{fill:gold}.speaker-box,.textbox{fill:hsl(var(--hue),var(--saturation),var(--luminance));stroke:#000;stroke-width:var(--strokeWidth)}.speaker-box__text,.textbox__text{fill:#fff;font-family:var(--fontFamily)}.speaker-box__text,.textbox__text,.time{font-size:.2em}.speaker-avatar__pic--narrator{stroke:hsl(var(--hue),var(--saturation),var(--luminance))}</style></head>
<body>
<main id="app">
<section>
<nav>
<ul class="nav-list">
<li class="nav-list__item">
<a href="#tab-inventory" class="nav-link">
<!-- TODO: Translateable! -->
Inventory
</a>
</li>
<li class="nav-list__item">
<a href="#tab-memory" class="nav-link">
<!-- TODO: Translateable! -->
Memory
</a>
</li>
<li class="nav-list__item">
<a href="#tab-settings" class="nav-link">
<!-- TODO: Translateable! -->
Settings
</a>
</li>
<li class="nav-list__item">
<a href="#tab-debug" class="nav-link">
<!-- TODO: Translateable! -->
Debug
</a>
</li>
</ul>
</nav>
</section>
<section id="tab-inventory" class="tab-view">
<!-- TODO: Translateable! -->
No items.
</section>
<section id="tab-memory" class="tab-view">
<!-- TODO: Translateable! -->
Make some encounters
</section>
<section id="tab-settings" class="tab-view">
<!-- TODO: Translateable! -->
<form id="form-settings" action="#" method="GET">
<fieldset>
<legend>
<!-- TODO: Translateable! -->
Language
</legend>
<select name="language">
<!-- TODO: Translateable! -->
Language
<option value="en">
<!-- TODO: Translateable! -->
English
</option>
</select>
<label>
<!-- TODO: Translateable! -->
Typing speed
<input type="range" min="1" max="3" step="1">
</label>
</fieldset>
</form>
</section>
<section id="tab-debug" class="tab-view">
<button id="action" type="button">
<!-- TODO: Translateable! -->
Start time
</button>
</section>
</main>
<script>/**
 * This file is part of JS13kGames - 404.
 * An Offline Life is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * An Offline Life is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with An Offline Life.  If not, see <https://www.gnu.org/licenses/>.
 */

(function () {
  'use strict';

  const EVENTS = {
    TICK: 'game:time:update',
    TURN: 'game:controls:turn',
    WIND: 'world:weather:wind',
    WORLD: 'game:world:switch'
  };

  class WithBoundingBox {
    constructor (properties) {
      const { x, y, height, width } = properties.boundingBox;
      this._boundingBox = {
        x,
        y,
        h: height,
        w: width
      };
    }
  }

  // TODO: Turn into real mixin
  class WithEventListener extends WithBoundingBox {
    constructor (properties) {
      super(properties);
      this._eventNode = properties.eventNode;

      Object.keys(this._getEventMap()).forEach((eventName) => {
        this._eventNode.addEventListener(eventName, this, false);
      });
    }

    // Implementation of EventHandler interface
    handleEvent (event) {
      const { detail, isTrusted, target, type } = event;
      const callback = this._getEventMap()[ type ];

      if (callback) {
        // Native Events
        if (isTrusted && target) {
          callback(target);
          return
        }

        // Custom Events
        if (!isTrusted && detail) {
          callback(detail);
          return
        }

        // Everything else
        console.warn(`Unknown event type ${type}`);
        callback(event);
        return
      } else {
        console.warn(`No callback for ${event.type}`);
      }
    }

    _getEventMap () {
      // To be overriden by sub-classes
      return {}
    }
  }

  // TODO: Turn into real mixin
  class WithLife extends WithEventListener {
    constructor (properties) {
      super(properties);

      this._life = 100;
    }

    _updateView () {
      if (!this.element) {
        throw new Error('Requires Element')
      }
      this.element.style.setProperty('--saturation', this._life + '%', '');
    }
  }

  // TODO: Turn into real mixin
  class WithSympathy extends WithLife {
    constructor (properties) {
      super(properties);

      this._sympathy = 0;
    }

    _mapSympathyToLuminance () {
      return 50 + this._sympathy / 2
    }

    _updateView () {
      super._updateView();
      if (!this.element) {
        throw new Error('Requires Element')
      }
      const luminance = this._mapSympathyToLuminance();
      this.element.style.setProperty('--luminance', luminance + '%', '');
    }
  }

  // TODO: Turn into real mixin
  class WithParent extends WithSympathy {
    constructor (properties) {
      super(properties);
      this._mount(properties.parent);
    }

    _createHtmlElement (name, attributes = {}, classes = []) {
      const element = document.createElement(name);

      Object.keys(attributes).forEach((attribute) => {
        const value = attributes[ attribute ];
        element.setAttribute(attribute, value);
      });

      classes.forEach((className) => {
        element.classList.add(className);
      });

      return element
    }

    _createSvgElement (name, attributes = {}, classes = []) {
      const ns = 'http://www.w3.org/2000/svg';
      const element = document.createElementNS(ns, name);

      Object.keys(attributes).forEach((attribute) => {
        const value = attributes[ attribute ];
        element.setAttributeNS(null, attribute, value);
      });

      classes.forEach((className) => {
        element.classList.add(className);
      });

      return element
    }

    _mount (parent) {
      throw new Error('Requires implementation')
    }
  }

  class Canvas extends WithParent {
    _mount (parent) {
      const { x, y, h, w } = this._boundingBox;

      this.element = this._createSvgElement(
        'svg',
        { viewBox: `${x} ${y} ${w} ${h}` },
        []
      );
      this.element.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

      parent.appendChild(this.element);
    }
  }

  class Controls extends WithParent {
    _getEventMap () {
      return { click: this._handleClick.bind(this) }
    }

    _handleClick (eventTarget) {
      const isLeftControl = eventTarget.classList.contains('left');
      const isRightControl = eventTarget.classList.contains('right');
      const isTopControl = eventTarget.classList.contains('top');

      if (isLeftControl) {
        const event = new CustomEvent(
          EVENTS.TURN,
          { detail: { direction: 'left' }}
        );
        this._eventNode.dispatchEvent(event);
      }

      if (isRightControl) {
        const event = new CustomEvent(
          EVENTS.TURN,
          { detail: { direction: 'right' }}
        );
        this._eventNode.dispatchEvent(event);
      }

      if (isTopControl) {
        const event = new CustomEvent(
          EVENTS.TURN,
          { detail: { direction: 'top' }}
        );
        this._eventNode.dispatchEvent(event);
      }
    }

    _mount (parent) {
      this.element = this._createSvgElement('g', {}, [ 'controls' ]);
      parent.appendChild(this.element);

      this._mountLeft();
      this._mountTop();
      this._mountRight();
    }

    _mountLeft () {
      const { x, y, h, w } = this._boundingBox;
      const top = y + h / 2;
      const bottom = y + h;
      const left = x;
      const right = x + w / 3;

      const points = [
        right + ',' + top,
        right + ',' + bottom,
        left  + ',' + (top + bottom) / 2
      ].join(' ');

      const control = this._createSvgElement(
        'polygon',
        { points },
        [ 'left', 'control' ]
      );
      this.element.appendChild(control);
    }

    _mountRight () {
      const { x, y, h, w } = this._boundingBox;
      const top = y + h / 2;
      const bottom = y + h;
      const left = x + w * 2 / 3;
      const right = x + w;

      const points = [
        left + ',' + top,
        left + ',' + bottom,
        right  + ',' + (top + bottom) / 2
      ].join(' ');

      const control = this._createSvgElement(
        'polygon',
        { points },
        [ 'right', 'control' ]
      );
      this.element.appendChild(control);
    }

    _mountTop () {
      const { x, y, h, w } = this._boundingBox;
      const top = y;
      const bottom = y + h / 2;
      const left = x + w / 3;
      const right = x + w * 2 / 3;

      const points = [
        right + ',' + bottom,
        left + ',' + bottom,
        (right + left) / 2  + ',' + top
      ].join(' ');

      const control = this._createSvgElement(
        'polygon',
        { points },
        [ 'top', 'control' ]
      );
      this.element.appendChild(control);
    }
  }

  class Time extends WithParent {
    constructor (properties) {
      super(properties);

      this.clock = {
        hour: 0,
        minute: 0
      };
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      if (!clock.hour || !clock.minute) {
        console.warn('Invalid event', clock);
        return
      }

      const hour = clock.hour;
      const minute = ('00' + clock.minute).slice(-2);
      this.clock = {
        hour,
        minute
      };
      this._updateView();
    }

    _mount (parent) {
      const { x, y } = this._boundingBox;
      this.element = this._createSvgElement(
        'text',
        { x, y },
        [ 'time' ]
      );

      const text = document.createTextNode('');
      this.element.appendChild(text);
      parent.appendChild(this.element);
    }

    _updateView () {
      super._updateView();
      const { hour, minute } = this.clock;
      this.element.textContent = `${hour}:${minute}`;
    }
  }

  const T = {
    WELCOME: 'Welcome, stranger'
  };

  class TextBox extends WithParent {
    constructor (properties) {
      super(properties);
      // Valid options: serif, sans-serif, monospace, cursive, fantasy
      this.style = 'serif';
      this.text = '';

      this._hue = 42;
    }

    showText (message, style = 'serif') {
      this.style = style;
      this.text = message;
      this._updateView();
    }

    _mount (parent) {
      const { x, y, h, w } = this._boundingBox;
      const strokeWidth = h * 0.02;
      this.element = this._createSvgElement(
        'g',
        {},
        []
      );

      const box = this._createSvgElement(
        'rect',
        {
          x,
          y: y + h * 0.6,
          height: h * 0.5,
          width: w,
          rx: w * 0.02,
          ry: w * 0.02
        },
        [ 'textbox' ]
      );
      box.style.setProperty('--strokeWidth', strokeWidth + '', '');
      this.element.appendChild(box);

      const text = this._createSvgElement(
        'text',
        {
          x: x + w * 0.03,
          y: y + h * 0.73
        },
        [ 'textbox__text' ]
      );

      const content = document.createTextNode('');
      text.appendChild(content);
      this.element.appendChild(text);
      parent.appendChild(this.element);
    }

    _updateView () {
      super._updateView();
      const textbox = this.element.querySelector('.textbox');
      textbox.style.setProperty('--hue', this._hue + '', '');

      const text = this.element.querySelector('.textbox__text');
      text.style.setProperty('--fontFamily', this.style + '', '');
      text.textContent = this.text;
    }
  }

  class Person extends TextBox {
    constructor (properties) {
      super(properties);
      this.name = '';
      this._updateView();
    }

    _mount (parent) {
      super._mount(parent);
      const { x, y, h, w } = this._boundingBox;
      const strokeWidth = h * 0.02;
      const speakerBox = this._createSvgElement(
        'rect',
        {
          x: x + w * 0.05,
          y: y + h * 0.53,
          height: h * 0.15,
          width: w * 0.2
        },
        [ 'speaker-box' ]
      );
      speakerBox.style.setProperty('--strokeWidth', strokeWidth + '', '');
      this.element.appendChild(speakerBox);

      const speakerName = this._createSvgElement(
        'text',
        {
          x: x + w * 0.07,
          y: y + h * 0.63
        },
        [ 'speaker-box__text' ]
      );

      const content = document.createTextNode('');

      speakerName.appendChild(content);
      this.element.appendChild(speakerName);

      const text = this.element.querySelector('.textbox__text');
      text.setAttributeNS(null, 'y', y + h * 0.78 + '');
    }

    _updateView () {
      super._updateView();
      const speakerBox = this.element.querySelector('.speaker-box');
      speakerBox.style.setProperty('--hue', this._hue + '', '');

      const speakerName = this.element.querySelector('.speaker-box__text');
      speakerName.style.setProperty('--fontFamily', this.style + '', '');
      speakerName.textContent = this.name;
    }
  }

  class Narrator extends Person {
    constructor (properties) {
      super(properties);
      this.name = '???';
      this.style = 'fantasy';

      this._hue = 42;
      this._updateView();
    }

    _mount (parent) {
      super._mount(parent);
      const { x, y, h, w } = this._boundingBox;

      const left   = x + w * 0.1;
      const right  = x + w * 0.2;
      const top    = y + h * 0.2;
      const bottom = y + h * 0.5;

      const points = [
         left              + ',' + (top    + h * 0.05),
        (left  + w * 0.05) + ',' +  top,
        (right - w * 0.05) + ',' +  top,
         right             + ',' + (top    + h * 0.05),
         left              + ',' + (bottom - h * 0.05),
        (left  + w * 0.05) + ',' +  bottom,
        (right - w * 0.05) + ',' +  bottom,
         right             + ',' + (bottom - h * 0.05)
      ].join(' ');

      const background = this._createSvgElement(
        'ellipse',
        {
          cx: x + w * 0.15,
          cy: y + h * 0.5,
          rx: w * 0.11,
          ry: h * 0.35
        },
        [ 'speaker-avatar__background' ]
      );

      const avatar = this._createSvgElement(
        'polyline',
        { points },
        [ 'speaker-avatar__pic', 'speaker-avatar__pic--narrator' ]
      );
      avatar.setAttributeNS(null, 'stroke-linecap', 'round');

      this.element.insertBefore(avatar, this.element.firstChild);
      this.element.insertBefore(background, this.element.firstChild);
    }

    _updateView () {
      super._updateView();
      const avatar = this.element.querySelector('.speaker-avatar__pic');
      avatar.style.setProperty('--hue', this._hue + '', '');
    }
  }

  class BaseWorld extends WithParent {
    static worldName = 'base'

    constructor (properties) {
      super(properties);
      this._isActive = false;
      this._updateView();
    }

    addScene () {
      this._addBackground();
      this._addMiddleground();
      this._addForeground();
    }

    isActive () {
      return this._isActive
    }

    setActive () {
      this._isActive = true;
      this._updateView();
    }

    setInactive () {
      this._isActive = false;
      this._updateView();
    }

    _addBackground () {
      // To be implemented in sub-classes
    }

    _addForeground () {
      // To be implemented in sub-classes
    }

    _addMiddleground () {
      // To be implemented in sub-classes
    }

    _mount (parent) {
      const classes = ['world', 'world--' + this.constructor.worldName];
      this.element = this._createSvgElement('g', {}, classes);
      parent.appendChild(this.element);
    }

    _rollDice (min = 1, max = 6) {
      return Math.floor(Math.random() * ((max - min) + min) + min)
    }

    _updateView () {
      super._updateView();
      if (this.isActive()) {
        this.element.classList.remove('hidden');
      } else {
        this.element.classList.add('hidden');
      }
    }
  }

  class IntroWorld extends BaseWorld {
    static worldName = 'intro'

    constructor (properties) {
      super(properties);
    }

    addScene () {
      this._addForeground();
      this._showIntro();
    }

    _addForeground () {
      const { x, y, h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x: x + w * 0.05,
          y: y + h * 0.40,
          height: h * 0.45,
          width: w * 0.9
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      this._narrator = new Narrator(properties);
    }

    _showIntro () {
      this._narrator.showText(T.WELCOME);
    }
  }

  class FivePortal extends WithParent {
    constructor (properties) {
      super(properties);

      this._hue = 0;
      this._life = 100;
      this._sympathy = 0;
      this._updateView();
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      if (!clock.hour || !clock.minute) {
        console.warn('Invalid event', clock);
        return
      }

      this._hue = (clock.hour * 60 + clock.minute) / (24 * 60) * 360;
      this._updateView();
    }

    _mount (parent) {
      const { x, y, h, w } = this._boundingBox;
      const strokeWidth = 0.08 * w;
      const points = [
        (x + w * 0.5)         + ',' + (y     + strokeWidth),
        (x + w - strokeWidth) + ',' + (y + h * 0.4),
        (x + w * 0.7)         + ',' + (y + h - strokeWidth),
        (x + w * 0.3)         + ',' + (y + h - strokeWidth),
        (x     + strokeWidth) + ',' + (y + h * 0.4)
      ].join(' ');

      this.element = this._createSvgElement(
        'polygon',
        { points },
        [ 'five-portal' ]
      );

      this.element.style.setProperty('--strokeWidth',  strokeWidth + '', '');
      parent.appendChild(this.element);
    }

    _updateView () {
      super._updateView();
      this.element.style.setProperty('--hue', this._hue + '', '');
    }
  }

  class FivePortalWorld extends BaseWorld {
    static worldName = 'five-portal'

    _addBackground () {
      const { x, y, h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x,
          y,
          height: h,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new FivePortal(properties);
    }
  }

  class FourPortal extends WithParent {
    constructor (properties) {
      super(properties);

      this._hue = 0;
      this._life = 100;
      this._sympathy = 0;
      this._updateView();
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      if (!clock.hour || !clock.minute) {
        console.warn('Invalid event', clock);
        return
      }

      this._hue = (clock.hour * 60 + clock.minute) / (24 * 60) * 360;
      this._updateView();
    }

    _mount (parent) {
      const { x, y, h, w } = this._boundingBox;
      const strokeWidth = 0.08 * w;
      const points = [
        (x + w * 0.5)         + ',' + (y     + strokeWidth),
        (x + w - strokeWidth) + ',' + (y + h * 0.5),
        (x + w * 0.5)         + ',' + (y + h - strokeWidth),
        (x     + strokeWidth) + ',' + (y + h * 0.5)
      ].join(' ');

      this.element = this._createSvgElement(
        'polygon',
        { points },
        [ 'four-portal' ]
      );

      this.element.style.setProperty('--strokeWidth',  strokeWidth + '', '');
      parent.appendChild(this.element);
    }

    _updateView () {
      super._updateView();
      this.element.style.setProperty('--hue', this._hue + '', '');
    }
  }

  class FourPortalWorld extends BaseWorld {
    static worldName = 'four-portal'

    _addBackground () {
      const { x, y, h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x,
          y,
          height: h,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new FourPortal(properties);
    }
  }

  class SixPortal extends WithParent {
    constructor (properties) {
      super(properties);

      this._hue = 0;
      this._life = 100;
      this._sympathy = 0;
      this._updateView();
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      if (!clock.hour || !clock.minute) {
        console.warn('Invalid event', clock);
        return
      }

      this._hue = (clock.hour * 60 + clock.minute) / (24 * 60) * 360;
      this._updateView();
    }

    _mount (parent) {
      const { x, y, h, w } = this._boundingBox;
      const strokeWidth = 0.08 * w;
      const points = [
        (x + w * 0.3)         + ',' + (y     + strokeWidth),
        (x + w * 0.7)         + ',' + (y     + strokeWidth),
        (x + w - strokeWidth) + ',' + (y + h * 0.5),
        (x + w * 0.7)         + ',' + (y + h - strokeWidth),
        (x + w * 0.3)         + ',' + (y + h - strokeWidth),
        (x     + strokeWidth) + ',' + (y + h * 0.5)
      ].join(' ');

      this.element = this._createSvgElement(
        'polygon',
        { points },
        [ 'six-portal' ]
      );

      this.element.style.setProperty('--strokeWidth',  strokeWidth + '', '');
      parent.appendChild(this.element);
    }

    _updateView () {
      super._updateView();
      this.element.style.setProperty('--hue', this._hue + '', '');
    }
  }

  class ThreePortal extends WithParent {
    constructor (properties) {
      super(properties);

      this._hue = 0;
      this._life = 100;
      this._sympathy = 0;
      this._updateView();
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      if (!clock.hour || !clock.minute) {
        console.warn('Invalid event', clock);
        return
      }

      this._hue = (clock.hour * 60 + clock.minute) / (24 * 60) * 360;
      this._updateView();
    }

    _mount (parent) {
      const { x, y, h, w } = this._boundingBox;
      const strokeWidth = 0.08 * w;
      const points = [
        (x + w * 0.5)         + ',' + (y + strokeWidth),
        (x + w - strokeWidth) + ',' + (y + h - strokeWidth),
        (x     + strokeWidth) + ',' + (y + h - strokeWidth),
      ].join(' ');

      this.element = this._createSvgElement(
        'polygon',
        { points },
        [ 'three-portal' ]
      );

      this.element.style.setProperty('--strokeWidth',  strokeWidth + '', '');
      parent.appendChild(this.element);
    }

    _updateView () {
      super._updateView();
      this.element.style.setProperty('--hue', this._hue + '', '');
    }
  }

  class PortalWorld extends BaseWorld {
    static worldName = 'portal'

    constructor (properties) {
      super(properties);
      this._portalLength = 0.3;
    }

    _addBackground () {
      this._portalLength = 0.3;
      this._addThreePortal();
      this._addFourPortal();
      this._addFivePortal();
      this._addSixPortal();
    }

    _addFivePortal () {
      const { x, y, h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x: x + w * (1 - this._portalLength),
          y: y + h * (0.5 - this._portalLength / 2),
          height: h * this._portalLength,
          width: w * this._portalLength
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new FivePortal(properties);
    }

    _addFourPortal () {
      const { x, y, h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x,
          y: y + h * (0.5 - this._portalLength / 2),
          height: h * this._portalLength,
          width: w * this._portalLength
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new FourPortal(properties);
    }

    _addSixPortal () {
      const { x, y, h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x: x + w * (0.5 - this._portalLength / 2),
          y: y + h * (1 - this._portalLength),
          height: h * this._portalLength,
          width: w * this._portalLength
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new SixPortal(properties);
    }

    _addThreePortal () {
      const { x, y, h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x: x + w * (0.5 - this._portalLength / 2),
          y,
          height: h * this._portalLength,
          width: w * this._portalLength
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new ThreePortal(properties);
    }

    _getEventMap () {
      return {
        'click': this._handleClick.bind(this)
      }
    }

    _handleClick (eventTarget) {
      const nextWorld = eventTarget.getAttribute('class');
      console.log('Clicked world', eventTarget, nextWorld);
      if (!nextWorld || nextWorld && !nextWorld.includes('-portal')) {
        return
      }
      const event = new CustomEvent(
        EVENTS.WORLD,
        { detail: { nextWorld }}
      );
      this._eventNode.dispatchEvent(event);
    }
  }

  class SixPortalWorld extends BaseWorld {
    static worldName = 'six-portal'

    _addBackground () {
      const { x, y, h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x,
          y,
          height: h,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new SixPortal(properties);
    }
  }

  class ThreePortalWorld extends BaseWorld {
    static worldName = 'three-portal'

    _addBackground () {
      const { x, y, h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x,
          y,
          height: h,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new ThreePortal(properties);
    }
  }

  class Guild extends WithParent {
    _mount (parent) {
      this.element = this._createSvgElement(
        'g',
        {},
        [ 'guild' ]
      );

      parent.appendChild(this.element);
      this._mountMarket();
    }

    _mountMarket () {
      const { x, y, h, w } = this._boundingBox;
      const left = x;
      const right = x + w;
      const top = y;
      const bottom = y + h;
      const middle = x + w * 0.5;

      const points = [
        left   + ',' + bottom,
        left   + ',' + (top + h * 0.1),
        middle + ',' +  top,
        right  + ',' + (top + h * 0.1),
        right  + ',' + bottom
      ].join(' ');

      const market = this._createSvgElement(
        'polygon',
        { points },
        [ 'market' ]
      );

      this.element.appendChild(market);
    }
  }

  class Sun extends WithParent {
    constructor (properties) {
      super(properties);

      this._radius = 3;
      this._axisX = this._boundingBox.x;
      this._axisY = this._boundingBox.y;
    }

    _getElementAttributes () {
      this._radius = this._radius || 3;
      this._axisX = this._axisX || this._boundingBox.x;
      this._axisY = this._axisY || this._boundingBox.y;

      return {
        r: this._radius,
        cx: this._axisX,
        cy: this._axisY
      }
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      const { hour, minute } = clock;
      if (!hour || !minute) {
        // TODO: Investigate
        console.warn('Invalid event', clock);
        return
      }

      const { x, y, h, w } = this._boundingBox;

      const dawn = 6;
      const dust = 18;

      const currentTime = (hour - dawn) * 60 + minute;
      const lengthOfDay = (dust - dawn) /* hours */ * 60; /* in minutes */
      const isDay = hour >= dawn && hour <= dust;

      let axisX = -5;

      if (isDay) {
        axisX = w * currentTime / lengthOfDay;
      }
      const angle = (hour + dawn) * 60 + minute;
      const lowerBorder = this._radius + h;
      const scale = h;

      const axisY = lowerBorder + scale * Math.sin(
        // Rescale to lengthOfDay
        angle * Math.PI / lengthOfDay
      );

      this._axisX = axisX;
      this._axisY = axisY;
      this._updateView();
    }

    _mount (parent) {
      const { r, cx, cy } = this._getElementAttributes();

      this.element = this._createSvgElement(
        'circle',
        {
          r: r + '',
          cx: cx - r * 3 + '',
          cy: cy - r * 3 + ''
        },
        [ 'sun' ]
      );
      parent.appendChild(this.element);
    }

    _updateView () {
      super._updateView();
      const cx = this._axisX;
      const cy = this._axisY;
      this.element.setAttributeNS(null, 'cx', cx + '');
      this.element.setAttributeNS(null, 'cy', cy + '');
    }
  }

  class FiveTownWorld extends BaseWorld {
    static worldName = 'five-town'

    constructor (properties) {
      super(properties);
    }

    addScene () {
      this._addBackground();
      this._addSun();
      this._addMiddleground();
      this._addForeground();
      this._addGuild();
    }

    playMusic () {
      /* Taken from https://xem.github.io/miniMusic/simple.html */
      // Frequencies taken from https://pages.mtu.edu/~suits/notefreqs.html
      // See also https://www.artofcomposing.com/how-to-compose-music-101
      // And https://twitter.com/mknol/status/1301193570842484738
      // More tools at https://twitter.com/MaximeEuziere/status/1288918702776356866
      /*
      with(new AudioContext)
      with(G=createGain())
      for(i in D=[1,,,,1,1,,,,,1,,,,1,1])
      with(createOscillator())
      if(D[i])
      connect(G),
      G.connect(destination),
      start(i*.1),
      frequency.setValueAtTime(262*1.06**(13-D[i]),i*.1),
      gain.setValueAtTime(1,i*.1),
      gain.setTargetAtTime(.0001,i*.1+.08,.005),
      stop(i*.1+.09)
      */
    }

    _addBackground () {
    }

    _addForeground () {
    }

    _addGuild () {
      const { x, y, h, w } = this._boundingBox;

      const properties = {
        boundingBox: {
          x: x + w * 0.3,
          y: y + h * 0.2,
          height: h * 0.6,
          width: w * 0.4
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Guild(properties);
    }

    _addMiddleground () {
    }

    _addSun () {
      const { x, y, h, w } = this._boundingBox;
      const backgroundHeight = h / 3;

      const properties = {
        boundingBox: {
          x,
          y,
          height: backgroundHeight,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Sun(properties);
    }
  }

  class Background extends WithParent {
    constructor (properties) {
      super(properties);

      this._hue = 211;
      this._saturation = 70;
      this._luminance = 50;

      this._timeoutHandle = null;
      this._updateView();
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      // TODO: Extract into mixin for shared code with Sun
      const isMorning = clock.hour > 5 && clock.hour < 8;
      const isEvening = clock.hour > 17 && clock.hour < 20;

      const delta = 6 / 60;  // change per minute

      if (isEvening) {
        this._luminance -= delta;
      }

      if (isMorning) {
        this._luminance += delta;
      }

      this._updateView();
    }

    _mount (parent) {
      const { x, y, h, w } = this._boundingBox;
      this.element = this._createSvgElement(
        'rect',
        {
          x,
          y,
          height: h,
          width: w
        },
        [ 'background' ]
      );

      parent.appendChild(this.element);
    }

    _updateView () {
      super._updateView();
      this.element.style.setProperty('--hue', this._hue + '', '');
      this.element.style.setProperty('--luminance', this._luminance + '%', '');
    }
  }

  class Foreground extends WithParent {
    constructor (properties) {
      super(properties);

      this._hue = 140;
      this._life = 50;
      this._luminance = 50;

      this._timeoutHandle = null;
      this._updateView();
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      // TODO: Extract into mixin
      const isMorning = clock.hour > 5 && clock.hour < 8;
      const isEvening = clock.hour > 17 && clock.hour < 20;

      const delta = 6 / 60;  // change per minute

      if (isEvening) {
        this._luminance -= delta;
      }

      if (isMorning) {
        this._luminance += delta;
      }

      this._updateView();
    }

    _mount (parent) {
      const { x, y, h, w } = this._boundingBox;
      this.element = this._createSvgElement(
        'rect',
        {
          x,
          y,
          height: h,
          width: w
        },
        [ 'foreground' ]
      );

      parent.appendChild(this.element);
    }

    _updateView () {
      super._updateView();
      this.element.style.setProperty('--hue', this._hue + '', '');
      this.element.style.setProperty('--luminance', this._luminance + '%', '');
    }
  }

  class Middleground extends WithParent {
    constructor (properties) {
      super(properties);

      this._hue = 140;
      this._life = 50;
      this._luminance = 30;

      this._timeoutHandle = null;
      this._updateView();
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      // TODO: Extract into mixin
      const isMorning = clock.hour > 5 && clock.hour < 8;
      const isEvening = clock.hour > 17 && clock.hour < 20;

      const delta = 6 / 60;  // change per minute

      if (isEvening) {
        this._luminance -= delta;
      }

      if (isMorning) {
        this._luminance += delta;
      }

      this._updateView();
    }

    _mount (parent) {
      const { x, y, h, w } = this._boundingBox;
      this.element = this._createSvgElement(
        'rect',
        {
          x,
          y,
          height: h,
          width: w
        },
        [ 'middleground' ]
      );

      parent.appendChild(this.element);
    }

    _updateView () {
      super._updateView();
      this.element.style.setProperty('--hue', this._hue + '', '');
      this.element.style.setProperty('--luminance', this._luminance + '%', '');
    }
  }

  class Castle extends WithParent {
    _mount (parent) {
      this.element = this._createSvgElement(
        'g',
        {},
        [ 'castle' ]
      );

      parent.appendChild(this.element);
      this._mountLeftTower();
      this._mountMain();
      this._mountCrenellations(4);
      this._mountRightTower();
    }

    _mountCrenellations (numberOfCrenellations) {
      const { x, y, h, w } = this._boundingBox;

      const breadth = w * 0.7 / (numberOfCrenellations * 2 + 1);
      const left = x + w * 0.15;
      const top = y + h * 0.1;
      const bottom = y + h * 0.2;

      const points = [
        left  + ',' + bottom,
      ];

      for (let i = 1; i < numberOfCrenellations * 2; i += 2) {
        const right = left + (i + 1) * breadth;

        points.push((left + i * breadth) + ',' + bottom);
        points.push((left + i * breadth) + ',' + top);
        points.push(right                + ',' + top);
        points.push(right                + ',' + bottom);
      }

      const crenellations = this._createSvgElement(
        'polygon',
        { points: points.join(' ') },
        [ 'crenellations' ]
      );
      this.element.appendChild(crenellations);
    }

    _mountLeftTower () {
      const { x, y, h, w } = this._boundingBox;

      const left = x;
      const right = x + w * 0.15;
      const top = y;
      const bottom = y + h;

      const points = [
        left  + ',' + bottom,
        left  + ',' + top,
        right + ',' + top,
        right + ',' + bottom
      ].join(' ');

      const tower = this._createSvgElement(
        'polygon',
        { points },
        [ 'tower' ]
      );
      this.element.appendChild(tower);
    }

    _mountMain () {
      const { x, y, h, w } = this._boundingBox;

      const left = x + w * 0.15;
      const right = x + w - w * 0.15;
      const top = y + h * 0.2;
      const bottom = y + h;

      const points = [
        left  + ',' + bottom,
        left  + ',' + top,
        right + ',' + top,
        right + ',' + bottom
      ].join(' ');

      const main = this._createSvgElement(
        'polygon',
        { points },
        []
      );
      this.element.appendChild(main);
    }

    _mountRightTower () {
      const { x, y, h, w } = this._boundingBox;

      const left = x + w - w * 0.15;
      const right = x + w;
      const top = y;
      const bottom = y + h;

      const points = [
        left  + ',' + bottom,
        left  + ',' + top,
        right + ',' + top,
        right + ',' + bottom
      ].join(' ');

      const tower = this._createSvgElement(
        'polygon',
        { points },
        [ 'tower' ]
      );
      this.element.appendChild(tower);
    }
  }

  class Mill extends WithParent {
    constructor (properties) {
      super(properties);

      const { x, y, h, w } = this._boundingBox;
      this._windStrength = 'still';
      this._axisX = x + w * 0.5;
      this._axisY = y + h * 0.3;
      this.degree = 0;

      this._updateView();
    }

    _getElementAttributes () {
      const { x, y, h, w } = this._boundingBox;

      this._axisX = this._axisX || x + w * 0.5;
      this._axisY = this._axisY || y + h * 0.5;
      this._degree = this._degree || 0;

      return {
        axisX: this._axisX,
        axisY: this._axisY,
        degree: this._degree
      }
    }

    _getEventMap () {
      return {
        [ EVENTS.TICK ]: this._handleGameTimeUpdate.bind(this),
        [ EVENTS.WIND ]: this._handleWorldWeatherWind.bind(this)
      }
    }

    _handleGameTimeUpdate (clock) {
      if (!clock.hour || !clock.minute) {
        console.warn('Invalid event', clock);
        return
      }

      // Must be divisable by 2/3 without remainder!
      let factor = 1.5;

      if (this._windStrength === 'medium') {
        factor = 6;
      }

      if (this._windStrength === 'strong') {
        factor = 9;
      }

      this._degree = clock.minute * factor;
      this._updateView();
    }

    _handleWorldWeatherWind (eventDetail) {
      this._windStrength = eventDetail.wind;
      this._updateView();
    }

    _mount (parent) {
      this.element = this._createSvgElement(
        'g',
        {},
        [ 'mill' ]
      );
      parent.appendChild(this.element);
      this._mountBuilding();
      this._mountWings();
    }

    _mountBuilding () {
      const { x, y, h, w } = this._boundingBox;

      const left = x + w * 0.3;
      const right = x + w * 0.7;
      const top = y + h * 0.3;
      const bottom = y + h;

      const points = [
        left              + ',' + bottom,
        (left + w * 0.1)  + ',' + top,
        (right - w * 0.1) + ',' + top,
        right             + ',' + bottom
      ].join(' ');

      const building = this._createSvgElement(
        'polygon',
        { points },
        []
      );
      this.element.appendChild(building);
    }

    _mountWings () {
      const wings = this._createSvgElement(
        'g',
        {},
        [ 'wings' ]
      );
      this._mountTopWing(wings);
      this._mountRightWing(wings);
      this._mountBottomWing(wings);
      this._mountLeftWing(wings);
      this.element.appendChild(wings);
    }

    _mountBottomWing (parent) {
      const { x, y, h, w } = this._boundingBox;
      const { axisX, axisY } = this._getElementAttributes();

      const left = axisX - w * 0.01;
      const right = axisX + w * 0.01;
      const top = axisY + h * 0.01;
      const bottom = axisY + h * 0.3;
      const middle = bottom - h * 0.2;

      const points = [
        right              + ',' + top,
        right              + ',' + bottom,
        left               + ',' + bottom,
        left               + ',' + middle,
        (right - w * 0.02) + ',' + middle,
        (right - w * 0.02) + ',' + top
      ].join(' ');

      const wing = this._createSvgElement(
        'polygon',
        { points },
        [ 'bottom', 'wing' ]
      );
      parent.appendChild(wing);
    }

    _mountLeftWing (parent) {
      const { x, y, h, w } = this._boundingBox;
      const { axisX, axisY } = this._getElementAttributes();

      const left = axisX - w * 0.3;
      const right = axisX - w * 0.01;
      const top = axisY - h * 0.1;
      const bottom = axisY + h * 0.01;
      const middle = left + w * 0.2;

      const points = [
        right  + ',' + bottom,
        left   + ',' + bottom,
        left   + ',' + top,
        middle + ',' + top,
        middle + ',' + (bottom - h * 0.02),
        right  + ',' + (bottom - h * 0.02)
      ].join(' ');

      const wing = this._createSvgElement(
        'polygon',
        { points },
        [ 'left', 'wing' ]
      );
      parent.appendChild(wing);
    }

    _mountRightWing (parent) {
      const { x, y, h, w } = this._boundingBox;
      const { axisX, axisY } = this._getElementAttributes();

      const left = axisX + w * 0.01;
      const right = axisX + w * 0.3;
      const top = axisY - h * 0.01;
      const bottom = axisY + h * 0.1;
      const middle = right - w * 0.2;

      const points = [
        left   + ',' + top,
        right  + ',' + top,
        right  + ',' + bottom,
        middle + ',' + bottom,
        middle + ',' + (top + h * 0.02),
        left   + ',' + (top + h * 0.02)
      ].join(' ');

      const wing = this._createSvgElement(
        'polygon',
        { points },
        [ 'right', 'wing' ]
      );
      parent.appendChild(wing);
    }

    _mountTopWing (parent) {
      const { x, y, h, w } = this._boundingBox;
      const { axisX, axisY } = this._getElementAttributes();

      const left = axisX - w * 0.01;
      const right = axisX + w * 0.1;
      const top = axisY + h * 0.3;
      const bottom = axisY - h * 0.01;
      const middle = top + h * 0.2;

      const points = [
        left              + ',' + bottom,
        left              + ',' + top,
        right             + ',' + top,
        right             + ',' + middle,
        (left + w * 0.02) + ',' + middle,
        (left + w * 0.02) + ',' + bottom
      ].join(' ');

      const wing = this._createSvgElement(
        'polygon',
        { points },
        [ 'top', 'wing' ]
      );
      parent.appendChild(wing);
    }

    _updateView () {
      super._updateView();
      const degree = this._degree;
      const origin = this._axisX + ',' + this._axisY;
      const rotate = `rotate(${degree},${origin})`;

      const wings = this.element.querySelector('.wings');
      wings.setAttributeNS(null, 'transform', rotate);
    }
  }

  class FourCastleWorld extends BaseWorld {
    static worldName = 'four-castle'

    constructor (properties) {
      super(properties);

      this._windChangeHandle = null;
    }

    addScene () {
      this._addBackground();
      this._addSun();
      this._addMiddleground();
      this._addMill();
      this._addCastle();
      this._addForeground();

      this.fireWindChange();
      const self = this;
      const delay = 4 * 1000;  // TODO: Bind to clock
      this._windChangeHandle = setInterval(self.fireWindChange.bind(self), delay);
    }

    fireWindChange () {
      const dice = this._rollDice();

      const winds = [
        null,
        'still', 'still',
        'medium', 'medium', 'medium',
        'strong'
      ];

      const wind = winds[ dice ];
      const event = new CustomEvent(EVENTS.WIND, { detail: { wind }});
      this._eventNode.dispatchEvent(event);
    }

    _addBackground () {
      const { x, y, h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x,
          y,
          height: h / 3,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Background(properties);
    }

    _addCastle () {
      const { x, y, h, w } = this._boundingBox;
      const controlsWidth = 5 * 3;

      const properties = {
        boundingBox: {
          x: x + controlsWidth,
          y: y + h * 0.4,
          height: h / 4,
          width: x + w * 0.75 - controlsWidth * 2
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Castle(properties);
    }

    _addForeground () {
      const { x, y, h, w } = this._boundingBox;
      const backgroundHeight = h / 3;
      const middlegroundHeight = h / 5;
      const offset = y + backgroundHeight + middlegroundHeight;
      const remainingHeight = h - offset;

      const properties = {
        boundingBox: {
          x,
          y: offset,
          height: remainingHeight,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Foreground(properties);
    }

    _addMiddleground () {
      const { x, y, h, w } = this._boundingBox;
      const backgroundHeight = h / 3;

      const properties = {
        boundingBox: {
          x,
          y: backgroundHeight,
          height: h / 5,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Middleground(properties);
    }

    _addMill () {
      const { x, y, h, w } = this._boundingBox;

      const properties = {
        boundingBox: {
          x: x + w * 0.7,
          y: y + h * 0.3,
          height: h * 0.2,
          width: w * 0.2
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Mill(properties);
    }
    _addSun () {
      const { x, y, h, w } = this._boundingBox;
      const backgroundHeight = h / 3;

      const properties = {
        boundingBox: {
          x,
          y,
          height: backgroundHeight,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Sun(properties);
    }
  }

  class SixMountainWorld extends BaseWorld {
    static worldName = 'six-mountain'

    constructor (properties) {
      super(properties);
    }

    addScene () {
      this._addBackground();
      this._addSun();
      this._addMiddleground();
      this._addForeground();
    }

    _addBackground () {
    }

    _addForeground () {
    }

    _addMiddleground () {
    }

    _addSun () {
      const { x, y, h, w } = this._boundingBox;
      const backgroundHeight = h / 3;

      const properties = {
        boundingBox: {
          x,
          y,
          height: backgroundHeight,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Sun(properties);
    }
  }

  class Hut extends WithParent {
    _mount (parent) {
      this.element = this._createSvgElement(
        'g',
        {},
        [ 'hut' ]
      );

      parent.appendChild(this.element);
      this._mountRoof();
      this._mountBuilding();
    }

    _mountBuilding () {
      const { x, y, h, w } = this._boundingBox;
      const top = y;
      const bottom = y + h * 0.8;
      const left = x + w * 0.05;
      const right = x + w * 0.95;
      const middle = x + w * 0.5;

      const points = [
        left   + ',' + bottom,
        middle + ',' + top,
        right  + ',' + bottom
      ].join(' ');

      const roof = this._createSvgElement(
        'polygon',
        { points },
        []
      );

      this.element.appendChild(roof);
    }

    _mountRoof () {
      const { x, y, h, w } = this._boundingBox;
      const top = y;
      const bottom = y + h * 0.6;
      const left = x;
      const right = x + w;
      const middle = x + w * 0.5;

      const points = [
        left   + ',' + bottom,
        middle + ',' + top,
        right  + ',' + bottom
      ].join(' ');

      const roof = this._createSvgElement(
        'polygon',
        { points },
        []
      );

      this.element.appendChild(roof);
    }
  }

  class Sea extends WithParent {
    constructor (properties) {
      super(properties);
      this._updateView();
    }

    _mount (parent) {
      this.element = this._createSvgElement(
        'g',
        {},
        [ 'sea' ]
      );

      parent.appendChild(this.element);
      // this._mountFilter()
      this._mountSky();
      this._mountWaves();
    }

    _mountFilter () {
      // Based on https://medium.com/swlh/using-the-svg-feturbulence-filter-for-wave-effects-2b8cb2546ee6
      // See also https://www.smashingmagazine.com/2015/05/why-the-svg-filter-is-awesome/
      this._filterId = 'sea-filter';
      let filter = document.querySelector(`#${this._filterId}`);
      if (filter !== null) {
        // Already created
        return
      }

      filter = this._createSvgElement(
        'filter',
        { id: this._filterId },
        []
      );

      const turbulence = this._createSvgElement(
        'feTurbulence',
        {
          id: 'turbulence',
          type: 'turbulence',
          baseFrequency: '0.042',
          numOctaves: '1',
          result: 'turbulence',
          seed: 5
        },
        []
      );

      const animate = this._createSvgElement(
        'animate',
        {
          id: 'animate',
          attributeName: 'baseFrequency',
          values: '0;0.1;0;0',
          from: '0',
          to: '100',
          dur: '10s',
          repeatCount: 'inifinte'
        },
        []
      );

      const displacement = this._createSvgElement(
        'feDisplacementMap',
        {
          in: 'SourceGraphic',
          in2: 'turbulence',
          scale: '30',
          xChannelSelector: 'R',
          yChannelSelector: 'R',
        },
        []
      );

      filter.appendChild(turbulence);
      filter.appendChild(animate);
      this.element.appendChild(filter);
      this.element.appendChild(displacement);
    }

    _mountSky () {
      const { x, y, h, w } = this._boundingBox;

      const top = y;
      const middle = y + h * 0.5;
      const left = x;
      const right = x + w;

      const points = [
        left  + ',' + top,
        right + ',' + top,
        right + ',' + middle
      ].join(' ');

      const sky = this._createSvgElement(
        'polygon',
        {
          points
        },
        [ 'sky' ]
      );
      this.element.appendChild(sky);
    }

    _mountWaves () {
      const { x, y, h, w } = this._boundingBox;
      const middle = y + h * 0.5;
      const bottom = y + h;
      const left = x;
      const right = x + w;

      const points = [
        right + ',' + middle,
        right + ',' + bottom,
        left  + ',' + bottom,
      ].join(' ');

      const waves = this._createSvgElement(
        'polygon',
        {
          // filter: `url(#${this._filterId})`,
          points
        },
        [ 'waves' ]
      );
      this.element.appendChild(waves);
    }
  }

  class ThreeVillageWorld extends BaseWorld {
    static worldName = 'three-village'

    constructor (properties) {
      super(properties);
    }

    addScene () {
      this._addBackground();
      this._addSun();
      this._addSea();
      this._addMiddleground();
      this._addForeground();
      this._addHut();
    }

    playMusic () {
      /*
      with(new AudioContext)
      with(G=createGain())
      for(i in D=[13,,,13,,,13,,13,13,,,,13,,,13,,,13,,13,13,,,,13,,,13,,,13,,13,13,,,,13,,,13,,,13,,13,13,,,,13,,,13,,,13,,13,13,,,,13,,,13,,,13,,13,13])
      with(createOscillator())
      if(D[i])
      connect(G),
      G.connect(destination),
      start(i*.1),
      frequency.setValueAtTime(262*1.06**(13-D[i]),i*.1),
      gain.setValueAtTime(1,i*.1),
      gain.setTargetAtTime(.0001,i*.1+.08,.005),
      stop(i*.1+.09)
      */
    }

    _addBackground () {
    }

    _addForeground () {
    }

    _addHut () {
      const { x, y, h, w } = this._boundingBox;
      const controlsWidth = 5 * 3;

      const properties = {
        boundingBox: {
          x: x + controlsWidth,
          y: y + h * 0.7,
          height: y + h * 0.25,
          width: w - controlsWidth * 2
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Hut(properties);
    }

    _addMiddleground () {
    }

    _addSea () {
      const { x, y, h, w } = this._boundingBox;
      const backgroundHeight = h / 3;

      const properties = {
        boundingBox: {
          x,
          y,
          height: backgroundHeight,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Sea(properties);
    }
   
    _addSun () {
      const { x, y, h, w } = this._boundingBox;
      const backgroundHeight = h / 3;

      const properties = {
        boundingBox: {
          x,
          y,
          height: backgroundHeight,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.element
      };

      new Sun(properties);
    }
  }

  class Game {
    constructor (mountPoint) {
      // super(properties)
      this.clock = {
        minute: 0,
        hour: 5,
        day: 1
      };

      // Matches <svg> viewPort
      this._boundingBox = {
        x: 0,
        y: 0,
        h: 100,
        w: 100
      };

      this._eventNode = mountPoint;
      this._parent = mountPoint;
      this._timeHandle = null;
      this._worlds = [];

      // TODO: Read from WithEventListener!
      Object.keys(this._getEventMap()).forEach((eventName) => {
        this._eventNode.addEventListener(eventName, this, false);
      });

      this._mount(mountPoint);
    }

    addWorlds () {
      const { x, y, h, w } = this._boundingBox;

      const properties = {
        boundingBox: {
          x,
          y,
          height: h,
          width: w
        },
        eventNode: this._eventNode,
        parent: this.canvas.element
      };

      const worlds = [{
        ctr: IntroWorld,
        left: PortalWorld.worldName,
        right: PortalWorld.worldName,
        top: PortalWorld.worldName
      }, {
        ctr: PortalWorld,
        left: PortalWorld.worldName,
        right: PortalWorld.worldName,
        top: PortalWorld.worldName
      }, {
        ctr: ThreePortalWorld,
        left: ThreeVillageWorld.worldName,
        right: ThreeVillageWorld.worldName,
        top: PortalWorld.worldName
      }, {
        ctr: ThreeVillageWorld,
        left: ThreePortalWorld.worldName,
        right: ThreePortalWorld.worldName,
        top: ThreeVillageWorld.worldName
      }, {
        ctr: FourPortalWorld,
        left: FourCastleWorld.worldName,
        right: FourCastleWorld.worldName,
        top: PortalWorld.worldName
      }, {
        ctr: FourCastleWorld,
        left: FourPortalWorld.worldName,
        right: FourPortalWorld.worldName,
        top: FourCastleWorld.worldName
      }, {
        ctr: FivePortalWorld,
        left: FiveTownWorld.worldName,
        right: FiveTownWorld.worldName,
        top: FivePortalWorld.worldName
      }, {
        ctr: FiveTownWorld,
        left: FivePortalWorld.worldName,
        right: FivePortalWorld.worldName,
        top: FiveTownWorld.worldName,
      }, {
        ctr: SixPortalWorld,
        left: SixMountainWorld.worldName,
        right: SixMountainWorld.worldName,
        top: SixPortalWorld.worldName
      }, {
        ctr: SixMountainWorld,
        left: SixPortalWorld.worldName,
        right: SixPortalWorld.worldName,
        top: SixMountainWorld.worldName
      }];

      worlds.forEach((w) => {
        const world = new w.ctr(properties);
        this._worlds.push({
          instance: world,
          name: w.ctr.worldName,
          left: w.left,
          right: w.right,
          top: w.top
        });

        world.addScene();
      });
    }

    fireNewTime () {
      this.clock.minute += 1;

      if (this.clock.minute >= 60) {
        this.clock.hour += 1;
        this.clock.minute -= 60;
      }

      if (this.clock.hour >= 24) {
        this.clock.day += 1;
        this.clock.hour -= 24;
      }

      const event = new CustomEvent(
        EVENTS.TICK,
        { detail: this.clock }
      );
      this._eventNode.dispatchEvent(event);
    }

    getCurrentWorld () {
      return this._worlds.find((world) => world.instance.isActive())
    }

    // TODO: Derive from WithEventListener!
    handleEvent (event) {
      const { detail, isTrusted, target, type } = event;
      const callback = this._getEventMap()[ type ];

      if (callback) {
        // Native Events
        if (isTrusted && target) {
          callback(target);
          return
        }

        // Custom Events
        if (!isTrusted && detail) {
          callback(detail);
          return
        }

        // Everything else
        console.warn(`Unknown event type ${type}`);
        callback(event);
        return
      } else {
        console.warn(`No callback for ${event.type}`);
      }
    }

    init () {
      const firstWorld = IntroWorld.worldName;

      this.addWorlds();
      // TODO: Only in debug builds?
      this._addTime();
      this._addControls();
      this.switchWorld({ nextWorld: firstWorld });
    }

    pauseTime () {
      clearInterval(this._timeHandle);
    }

    startTime () {
      const fps = 33;
      const self = this;
      this._timeHandle = setInterval(self.fireNewTime.bind(self), fps);
    }

    switchWorld ({ nextWorld }) {
      const world = this._worlds.find((w) => w.name == nextWorld);
      this._worlds.forEach((world) => world.instance.setInactive());
      console.log('Transitioning to ', nextWorld, world);
      world && world.instance.setActive();
    }

    _addControls () {
      const controlsHeight = 5 * 2;
      const controlsWidth = 5 * 3;

      // TODO: Consider left-handers!
      const controlsX = this._boundingBox.x + this._boundingBox.w - controlsWidth;
      const controlsY = this._boundingBox.y + this._boundingBox.h - controlsHeight;

      const properties = {
        boundingBox: {
          x: controlsX,
          y: controlsY,
          height: controlsHeight,
          width: controlsWidth
        },
        eventNode: this._eventNode,
        parent: this.canvas.element
      };

      const controls = new Controls(properties);
    }

    _addTime () {
      const { h, w } = this._boundingBox;
      const properties = {
        boundingBox: {
          x: 0.8 * h,
          y: 0.95 * w
        },
        eventNode: this._eventNode,
        parent: this.canvas.element
      };

      const time = new Time(properties);
    }

    _getEventMap () {
      return {
        [ EVENTS.TURN ]: this._handleGameControlsTurn.bind(this),
        [ EVENTS.WORLD ]: this.switchWorld.bind(this)
      }
    }

    _handleGameControlsTurn (eventDetail) {
      const currentWorld = this.getCurrentWorld();
      const nextWorld = currentWorld[ eventDetail.direction ];
      this.switchWorld({ nextWorld });
    }

    _mount (parent) {
      const properties = {
        boundingBox: {
          x: 0,
          y: 0,
          height: 100,
          width: 100
        },
        parent: this._parent,
        eventNode: this._eventNode
      };

      this.canvas = new Canvas(properties);
    }
  }

  const el = document.querySelector('#app');
  const game = new Game(el);
  game.init();

  let shallStart = true;

  document
    .getElementById('action')
    .addEventListener('click', () => {
      if (shallStart) {
        game.startTime();
      } else {
        game.pauseTime();
      }
      shallStart = !shallStart;
    }, false);

  // BIG Kudos to https://stackoverflow.com/a/16484266
  /*
  class World {
    constructor (element, data) {
      this.element = element
      this.data = data

      element.value = data
      element.addEventListener('change', this, false)
      element.addEventListener('click', this, false)
    }

    handleEvent (event) {
      switch (event.type) {
        case 'change':
          this.handleChange(this.element.value)
          break
        case 'click':
          this.handleClick()
          break
        default:
          // Do nothing
      }
    }

    handleChange (value) {
      this.data = value
      this.element.value = value
    }

    handleClick () {
      this.element.setAttributeNS(null, 'fill', `hsl(50, 0%, ${this.data}%)`)
      this.data += 2
    }
  }

  // TODO: Assign this to different children of #app
  // Modify World class to pass in the property to change. Perhaps a mapping of event to properties?
  // Allow for callbacks?
  new World(document.querySelector('#app rect'), 50)
  */

  /* Feature detection of Sensors API */
  /*
  if (typeof Gyroscope === 'function') {
  }

  if ('ProximitySensor' in window) {
  }

  if (window.Accelerometer) {
    console.log('Asking for permission to accelerometer')
    navigator.permissions.query({ name: 'accelerometer' })
             .then((result) => {
               if (result.state === 'denied') {
               console.log('Permission to use accelerometer sensor is denied.')
               return
             }
             console.log('Permission to use accelerometer sensor is granted.')

             let acl = new Accelerometer({ frequency: 60 })

             acl.addEventListener('reading', () => {
               console.log('Acceleration along the X-axis ' + acl.x)
               console.log('Acceleration along the Y-axis ' + acl.y)
               console.log('Acceleration along the Z-axis ' + acl.z)
             })

             acl.start()
             console.log('ACL', acl)
    })
  } else {
    console.info('No Accelerometer available')
  }

  if (window.AmbientLightSensor) {
    console.log('Asking for permission to ambient light sensor')
    navigator.permissions.query({ name: 'ambient-light-sensor' })
             .then((result) => {
               if (result.state === 'denied') {
               console.log('Permission to use ambient-light-sensor sensor is denied.')
               return
             }
             console.log('Permission to use ambient-light-sensor sensor is granted.')

             let sensor = new AmbientLightSensor()
             sensor.onreading = () => {
               console.log('Current light level: ', sensor.illuminance)
             }
             sensor.onerror = (event) => {
               console.error(event.error.name, event.error.message)
             }
             sensor.start()
             console.log('Ambient Light sensor', sensor)
    })
  } else {
    console.info('No AmbientLightSensor available')
  }

  if (window.Gyroscope) {
    console.log('Asking for permission to gyroscope')
    navigator.permissions.query({ name: 'gyroscope' })
             .then((result) => {
               if (result.state === 'denied') {
               console.log('Permission to use gyroscope sensor is denied.')
               return
             }
             console.log('Permission to use gyroscope sensor is granted.')

             let gyroscope = new Gyroscope({ frequency: 60 })

             gyroscope.addEventListener('reading', () => {
               console.log('Angular velocity along the X-axis ' + gyroscope.x)
               console.log('Angular velocity along the Y-axis ' + gyroscope.y)
               console.log('Angular velocity along the Z-axis ' + gyroscope.z)
             })

             gyroscope.start()
             console.log('Gyroscope', gyroscope)
    })
  } else {
    console.info('No Gyroscope available')
  }

  if (window.Magnetometer) {
    console.log('Asking for permission to magnetometer')
    navigator.permissions.query({ name: 'magnetometer' })
             .then((result) => {
               if (result.state === 'denied') {
               console.log('Permission to use magnetometer sensor is denied.')
               return
             }
             console.log('Permission to use magnetometer sensor is granted.')

             let magnetometer = new Magnetometer({ frequency: 60 })

             magnetometer.addEventListener('reading', () => {
               console.log('Magnetic field along the X-axis ' + magnetometer.x)
               console.log('Magnetic field along the Y-axis ' + magnetometer.y)
               console.log('Magnetic field along the Z-axis ' + magnetometer.z)
             })

             magnetometer.start()
             console.log('Magnetometer', magnetometer)
    })
  } else {
    console.info('No Magnetometer available')
  }
  */

  /* Sensors have the fields:
   * activated: Boolean
   * hasReading: Boolean
   * timestamp
   *
   * Sensors have the events:
   * reading
   * error
   * activated
   *
   * Sensors have the methods:
   * start()
   * stop()
   */

  /*
  radians = degrees * (pi/180)
  degrees = radians * (180/pi)
  */

  /*
   * x = r * cos(phi)
   * y = r * sin(phi)
   * r = (x * x + y * y)^(1/2)
   * phi = atan2(y, x) (= Math.atan2)
   */

  /*
  function handleMotionEvent(event) {
      var x = event.accelerationIncludingGravity.x
      var y = event.accelerationIncludingGravity.y
      var z = event.accelerationIncludingGravity.z

      // Do something awesome.
  }

  window.addEventListener('devicemotion', handleMotionEvent, true)

  if (window.DeviceOrientationEvent) {
      window.addEventListener('deviceorientation', function(event) {
          // alpha: rotation around z-axis
          var rotateDegrees = event.alpha
          // gamma: left to right
          var leftToRight = event.gamma
          // beta: front back motion
          var frontToBack = event.beta

          handleOrientationEvent(frontToBack, leftToRight, rotateDegrees);
      }, true)
  }

  var handleOrientationEvent = function(frontToBack, leftToRight, rotateDegrees) {
      // do something amazing
  }
  */

}());
</script>

</body></html>